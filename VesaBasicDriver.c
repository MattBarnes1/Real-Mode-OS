#include "UtilityItems.h"
#include "Math.h"
#include "malloc.h"
//https://stackoverflow.com/questions/2156572/c-header-file-with-bitmapped-fonts/2156872
unsigned char letters[95][13] = {0x00,0x00 };/*
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36},
{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18},
{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70},
{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e},
{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c},
{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30},
{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03},
{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06},
{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60},
{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e},
{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18},
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e},
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3},
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c},
{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60},
{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18},
{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03},
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e},
{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00},
{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00},
{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00},
{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f},
{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00}
};*/
int WindowGranularity;
int VideoPitch;
int BitsPerPixel;
int VESAScreenTextRows = 25;
int VESAScreenTextColumns = 80;
char CharWidth;
char CharHeight;
int xVideoCursor = 0;
int yVideoCursor = 0;
char Background;
char Foreground;
int xRes;
FARPTR WinFuncPtr;

struct VESAModeInfo
{
    int ModeAttributes;
    char WindowAAttribute;
    char WindowBAttribute;
    int Granularity;
    int WinSize;
    int SegA;
    int SegB;
    FARPTR WinFuncPtr;
    int BytesPerScanline;
    int xRes;
    int  yRes;
    char XCharSize;
    char YCharSize;
    char PlaneNumber;
    char BitsPerPixel;
    char BankNumber;
    char MemoryModel;
    char bankSizeKB;
};


struct VESAData
{
    char VESAID[4];
    int VesaVersion;
    FARPTR OEMString;
    char capabilities[4];
    FARPTR VideoModes;
    int blocks;
};
int blocks;

void SelectPage(int myPage)
{
	int Result;
				
	/*interrupt(23, '\n', 0, 0);
	interrupt(23, 'D', 0, 0);			
	interrupt(23, 'R', 0, 0, 0);			
	interrupt(23, 'W', 0, 0, 0);			
	interrupt(23, 'P', 0, 0, 0);			
	interrupt(23, 'A', 0, 0, 0);			
	interrupt(23, 'G', 0, 0, 0);			
	interrupt(23, 'E', 0, 0, 0);
	interrupt(33, 13, myPage, 1,0);	
	interrupt(23, '\n', 0, 0, 0);*/
    Result = ExtInterrupt(0x10, 0x4F05, 0,0,myPage, 0);
    if(WasValid(Result, 5) == 0)
    {		
	/*interrupt(23, '\n', 0, 0, 0);			
	interrupt(23, 'B', 0, 0, 0);			
	interrupt(23, 'A', 0, 0, 0);			
	interrupt(23, 'D', 0, 0, 0);			
	interrupt(23, 'P', 0, 0, 0);			
	interrupt(23, 'A', 0, 0, 0);			
	interrupt(23, 'G', 0, 0, 0);			
	interrupt(23, 'E', 0, 0, 0);
	interrupt(33, 13, myPage, 1,0);		
	interrupt(23, '\n', 0, 0, 0);*/
    }
}

void DrawPixel(int  Color, int x, int  y)
{

	int xVal = x*(BitsPerPixel/8);
	int yVal = y*VideoPitch;
	int page = div((yVal)  + xVal, WindowGranularity);	
	int offset = mod((yVal)  +  xVal, WindowGranularity); 
  	SelectPage(page);
	putInMemory(0xA000, offset, Color);
}

int TextColor =  0x07EF; //https://ee-programming-notepad.blogspot.com/2016/10/16-bit-color-generator-picker.html
void setTextColor_VESA(char top, char bottom)
{
	Background = top;
	Foreground = bottom;
}


void ScrollDown_VESA()
{

}

void IncrementYCursorCheck_VESA()
{
			interrupt(23, 'B', 0, 0, 0);	
			interrupt(23, 'Y', 0, 0, 0);			
			interrupt(23, 'C', 0, 0, 0);
			interrupt(33, 13, yVideoCursor,1,0);

	if(yVideoCursor + 1 > VESAScreenTextRows)
	{
		xVideoCursor = 0;		
		ScrollDown_VESA();
	} else {
		
		yVideoCursor++;
	}
			interrupt(23, 'A', 0, 0, 0);	
			interrupt(23, 'Y', 0, 0, 0);			
			interrupt(23, 'C', 0, 0, 0);
			interrupt(33, 13, yVideoCursor,1,0);
}

void IncrementXCursorCheck()
{
	if(xVideoCursor + 1 > VESAScreenTextColumns)
	{		
		if(yVideoCursor + 1 > VESAScreenTextRows)
		{					
			ScrollDown_VESA();
		} else {
			yVideoCursor++;
		}
		xVideoCursor = 0;	
	} else {
		xVideoCursor++;
	}
}


void setCursorPosition_VESA(int x, int y)
{
	xVideoCursor = x;
	yVideoCursor = y;
}

void DrawSquare(int color, int x, int y, int width, int height)
{
	int X = x;
	int Y = y;
	for (X; X < x + width; X++)
	{
		for(Y; Y < y + height; Y++)
		{
			DrawPixel(color, X, Y);
		}
	}
}


//0bRRRRRGGGGGGBBBBB

void writeCharacter_VESA(char c)
{	
	int stupidbcc;
	int offset = ((char)c) - 32; //Shifts our offset
	int XPosition;
	int YPosition;
	int Value;
	int i = 0;			
	if(offset < 0 || offset > 95) offset = 1;
	interrupt(33, 13, offset, 1,0);				
	interrupt(23, '\n', 0, 0, 0);
	if(c == ' ')
	{	
		IncrementXCursorCheck();
		return;
	}
	if(c == '\0') return;
	if(c == '\r') return;
	if(c == '\n')
	{
		IncrementYCursorCheck_VESA();
		xVideoCursor = 0;	
		return;
	}			
	interrupt(23, '\n', 0, 0, 0);			
	interrupt(23, 'F', 0, 0, 0);

	for(i = 0; i < 13 ; i++)
	{	
		int Result;	
		int XPosition = CharWidth + xVideoCursor*CharWidth;//CharWidth + xVideoCursor*CharWidth;	
		int YPosition = CharHeight+ yVideoCursor*CharHeight;//
		char myChar = letters[offset][i];
		/*interrupt(33, 13, myChar,1,0);
		interrupt(23, 'L', 0, 0, 0);
		interrupt(23, ' ', 0, 0, 0);		
		interrupt(23, ' ', 0, 0, 0);
		interrupt(33, 13, XPosition,1, 0);
		interrupt(23, ' ', 0, 0, 0);
		interrupt(23, ' ', 0, 0, 0);
		interrupt(33, 13, YPosition + i,1, 0);
		interrupt(23, ' ', 0, 0, 0);*/

		for(stupidbcc = 0; stupidbcc < 9; stupidbcc++)
		{
			Result = 0;
			Value = pow(2, stupidbcc);
			Result = myChar & Value;
			if(Result == Value) DrawPixel(TextColor, XPosition + stupidbcc, YPosition  + (CharHeight - i));
		}


			
		/*interrupt(23, 'F', 0, 0, 0);
		interrupt(23, 'I', 0, 0, 0);
		interrupt(23, 'N', 0, 0, 0);		
		interrupt(23, '\n', 0, 0, 0);*/

	}
	IncrementXCursorCheck();
	
}

void printString_VESA(char Arrays[], int value)
{
		int i = 0;
		unsigned int charArraySize = 0;		
		interrupt(23, 'C', 0, 0, 0);		
		interrupt(23, '\n', 0, 0, 0);

		interrupt(33,13, charArraySize, 1,0);
		while(Arrays[charArraySize] != '\0')
		{
			if(value == 0)
			{
				writeCharacter_VESA(Arrays[charArraySize]);
			} else {
				interrupt(23, Arrays[charArraySize], 0, 0, 0);
			}		
			charArraySize++;
		}
}



void PrintVESAModeInformation()
{



}

void VesaInternalSetup(struct VESAModeInfo *MySelected)
{
	CharWidth = MySelected->XCharSize;
	CharHeight = MySelected->YCharSize;
	WindowGranularity = MySelected->Granularity;
	xRes = MySelected->xRes;


	VideoPitch = MySelected->BytesPerScanline;	
	BitsPerPixel = MySelected->BitsPerPixel;
        
	VESAScreenTextRows =  div(MySelected->yRes, MySelected->YCharSize);
	VESAScreenTextColumns =  div(MySelected->xRes,MySelected->XCharSize);

}


void switchVideoMode(int x)
{
	int AX = 0x4F02;
	int BX = x;		
	interrupt(0x10, AX, BX , 0, 0);

}

int GetVesaInformation(char bpp, int expectedWidth, int expectedHeight)
{
	char c = ';';
	struct VESAModeInfo *VesaModeBest = (struct VESAData *)malloc(300);
	char MakerPrint[2];
	char *Version;
	//FARPTR Info;
	struct VESAModeInfo *temp;
	int AX = SetRegister(0x4F,0x00);
	int width = 0xFFFF;
	int height = 0xFFFF;
	int BestMode = 0x6A;
	int BestWidth, BestHeight;	
	unsigned int InfoReturned = 0;	
	struct VESAData *VesaData = (struct VESAData *)malloc(300);
	struct VESAModeInfo *VesaMode = (struct VESAModeInfo *)malloc(300);
	if(VesaData == 0) return 0;
	if(VesaMode == 0) return 0;
	interrupt(33,0,"\nChecking for VESA compatibility: \n\0", 0, 0);
	AX = ExtInterrupt(0x10, AX, 0, 0, 0, VesaData);	
	MakerPrint[1] = '\0';
	if(WasValid(AX, 0) == 1)
	{
		blocks = VesaData->blocks;
		if(VesaData->VESAID[0] != 'V' && VesaData->VESAID[1] != 'E') return 0; 
		interrupt(33, 0, "\n\n VESA Maker: \0", 0);
		while(c != '\0')
		{
			GetFarPointerData(VesaData->OEMString.Segment, VesaData->OEMString.Address++, &c, 1);
			MakerPrint[0] = c;
			interrupt(33, 0, MakerPrint,0,0);
		} 
		//interrupt(33, 0, "\n\0", 0, 0, 0);
		//interrupt(33, 0, "\nTotal Banks in Memory: \0", 0);
		//interrupt(33, 13, blocks, 0, 0);
		//interrupt(33, 0, "\n\0", 0, 0, 0);
		Version = &VesaData->VesaVersion;
		interrupt(33, 0, "\n\0", 0, 0, 0);
		interrupt(33, 0, "\nVersion: \0", 0);
		interrupt(33, 13, Version[1], 0, 0);
		interrupt(33, 0, ".", 0, 0, 0);		
		interrupt(33, 13, Version[0], 0, 0);
		interrupt(33, 0, "\n", 0, 0);
		GetFarPointerData( VesaData->VideoModes.Segment,  VesaData->VideoModes.Address, &InfoReturned , 2);
		while(InfoReturned != 0xFFFF)
		{
			if(PrintVesaScreen(InfoReturned, bpp, VesaMode, &width, &height) == 1)
			{
				 if(expectedWidth - BestWidth >= expectedWidth - width && expectedWidth - width >= 0 && expectedHeight - BestHeight >= expectedHeight - height&& expectedHeight - height >= 0)
				{
					BestMode = InfoReturned;
					temp = VesaModeBest;
					VesaModeBest = VesaMode;
					VesaMode = temp;
					BestHeight = height;
					BestWidth = width;
				}
			}
			GetFarPointerData( VesaData->VideoModes.Segment,  ++VesaData->VideoModes.Address, &InfoReturned , 2);
		}
		VesaInternalSetup(VesaModeBest);
		free(VesaMode);
		free(VesaData);
		switchVideoMode(BestMode);
		free(VesaModeBest);
		return 0;
	} 
	interrupt(33, 0, "Couldn't find a compatible mode!\0", 0 ,0);
    return 0;
}






int PrintVesaScreen(int Info, char bpp, struct VESAModeInfo *myVesa, int *ScreenWidth, int *ScreenHeight)
{
	int AX = 0x4F01;
	int CX = Info;
	AX = ExtInterrupt(0x10, AX, 0,CX,0,myVesa);
        *ScreenWidth = myVesa->xRes;
        *ScreenHeight = myVesa->yRes;
	if(myVesa->ModeAttributes & 0x80 != 0x80 && myVesa->ModeAttributes & 0x40 != 0) return 0;//Is window fram buffer supported 
	if(myVesa->MemoryModel != 6) return 0;
	if(myVesa->ModeAttributes & 1 != 1) return 0;
	if(myVesa->BitsPerPixel != bpp) return 0;
    if(WasValid(AX, 1) == 1)
    {
	interrupt(33, 0, "Video mode found -- Width: \0", 0 ,0);
	interrupt(33, 13, myVesa->xRes , 0,0);
	interrupt(33, 0, "  Height: \0", 0 ,0);
	interrupt(33, 13, myVesa->yRes, 0,0);	
	interrupt(33, 0, "  Bit: \0", 0 ,0);
	interrupt(33, 13, myVesa->BitsPerPixel, 0,0);
	interrupt(33, 0, "\n\0", 0 ,0);
	/*if(myVesa->WindowAAttribute & 1 == 1)
		interrupt(33, 0, " WinA Supported: Y \0", 0 ,0);
	else
		interrupt(33, 0, " WinA Supported: N \0", 0 ,0);
		
	if(myVesa->WindowAAttribute & 2 == 2)
		interrupt(33, 0, " WinA Readable: Y\0", 0 ,0);
	else
		interrupt(33, 0, " WinA Readable: N\0", 0 ,0);

	if(myVesa->WindowAAttribute & 4 == 4)
		interrupt(33, 0, " WinA Writeable: Y\0", 0 ,0);
	else
		interrupt(33, 0, " WinA Writeable: N\0", 0 ,0);

	if(myVesa->WindowBAttribute & 1 == 1)
		interrupt(33, 0, " WinB Supported: Y \0", 0 ,0);
	else
		interrupt(33, 0, " WinB Supported: N \0", 0 ,0);
		
	if(myVesa->WindowBAttribute & 2 == 2)
		interrupt(33, 0, " WinB Readable: Y\0", 0 ,0);
	else
		interrupt(33, 0, " WinB Readable: N\0", 0 ,0);

	if(myVesa->WindowBAttribute & 4 == 4)
		interrupt(33, 0, " WinB Writeable: Y\0", 0 ,0);
	else
		interrupt(33, 0, " WinB Writeable: N\0", 0 ,0);


	interrupt(33, 13, 1, 0,0);
	interrupt(33, 0, "\n\0", 0 ,0);
	interrupt(33, 13, myVesa->BitsPerPixel, 0,0);
	interrupt(33, 0, "\n\0", 0 ,0);*/

	return 1;
    }
	return 0;
}

int WasValid(int retVal, int FunctionCall)
{
	char *Value = &retVal;
	if(Value[0] != 0x4F || Value[1] != 0)
	{
		return 0;
	}
	return 1;
}


//5 bits red, 6 bits green, 5 bits blue
//32 red, 64, 32 

void ClearScreen_VESA(char back, char fore)
{	
	setTextColor_VESA(back, fore);

}

void ScrollUp_VESA()
{


}




